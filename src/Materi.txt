======================================== Pengenalan Collection ========================================
Collection adalah hal umum yang biasa dimiliki di bahasa pemrograman, seperti PHP, Python, Ruby dan lain - lain
Collection atau kadang disebut container, adalah object yang mengumpulkan atau berisikan data - data, mirip seperti Array
Java telah menyediakan class - class collection yang sudah bisa langsung kita gunakan, tanpa tambahan library
Semua class - class collection di Java adalah generic class, sehingga kita bisa menggunakan Java collection dengan data apapun

## Java Collection ##
Java collection telah menyediakan semuanya yang berhubungan dengan collection, sehinggga kita hanya cukup tinggal menggunakannya

    * Interface, ini adalah contract representasi dari collection. Semua collection di Java memiliki kontrak interface, sehingga jika kita mau, kita juga bisa membuat implementasinya sendiri
    * Implementations, tidak perlu khawatir, kita juga bisa menggunakan implementasi yang sudah dibuat oleh Java, semua interface collection sudah ada implementasi class nya di Java collection
    * Algorithms, Java juga sudah menyediakan algoritma - algoritma yang umum digunakan di collection, seperti pencarian dan pengurutan data di collection

======================================== Iterable & Iterator Interface ========================================
## Iterable Interface ##
Iterable adalah parent untuk semua collection di Java, kecuali Map
Iterable sendiri sangat sederhana, hanya digunakan agar mendukung for-each loop
Karena semua collection pasti implement iterable, secara otomatis maka semua collection di Java mendukung perulangan for-each, jadi bukan cuma Array

## Iterator Interface ##
Tidak ada magic di Java, sebenarnya for-each di Iterable bisa terjadi karena ada method iterator() yang mengembalikan object iterator
Iterator adalah interface yang mendefinisikan cara kita melakukan mengakses element di collection secara sequential
For-each sendiri muncul sejak Java 5, sebelum Java 5 untuk melakukan iterasi collection, biasanya dilakukan manual menggunakan Iterator object

======================================== Collection Interface ========================================
Selain Iterable interface, parent class semua collection di Java adalah Collection
Kalo Iterable interface digunakan sebagai kontrak untuk meng-iterasi data secara sequential
Collection merupakan kontrak untuk memanipulasi  data collection, seperti menambah, menghapus, dan mengecek isi data collection
Tidak ada direct implementation untuk Collection, karena collection nanti akan dibagi lagi menjadi List, Set dan Queue

======================================== List Interface========================================
List adalah struktur data collection yang memiliki sifat sebagai berikut
    * Elemen di list bisa duplikat, artinya bisa memasukkan data yang sama
    * Data list berurut sesuai dengan posisi kita memasukkan data
    * List memiliki index, sehingga kita bisa menggunakan nomor index untuk mendapatkan element di list
Di java ada beberapa implementasi List, dan kita bisa memilih sesuai dengan kebutuhan kita

## Implementasi List ##
                                 Iterable
                                     ^
                                     |
                                 Collection
                                     ^
                                     |
                       ArrayList--> List <-- LinkedList


## ArrayList Class ##
ArrayList adalah implementasi dari List menggunakan array
Default kapasitas array di ArrayList adalah 10
Namun ketika kita memasukkan data dan array yang sudah penuh, maka secara otomatis ArrayList akan membuat array baru dengan kapasitas baru dengan ukuran kapasitas lama + data baru

## LinkedList Class ##
LinkedList adalah implementasi List dengan struktur data Double Linked List
Bagi yang sudah belajar tentang struktur data di sekolah / kampus apa itu double linked list

## ArrayList vs LinkedLIst ##
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Operasi     | ArrayList                                                             | LinkedList
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
add         | Cepat jika kapasitasnya Array masih cukup, lamabat jika sudah penuh   | Cepat karena hanya menambah node di akhir
get         | Cepat karena tinggal digunakan index array                            | Lambat karena harus di cek dari node awal sampai ketemu index nya
set         | Cepat karena tinggal gunakan index array                              | Lambat karena harus di cek dari node awal sampai ketemu
remove      | Lambat karena harus menggeser data di belakang yang dihapus           | Cepat karena tinggal ubah prev dan next di node sebelah yang dihapus

======================================== Immutable List ========================================
Secara default, List di Java baik ArrayList ataupun LInkedList datanya bersifat mutable (Bisa diubah)
Di java mendukung pembuatan Immutable List, artinya datanya tidak bisa diubah lagi.
Sekali List dibuat, datanya tidak bisa diubah lagi, alias final
Tapi ingat, data listnya yang tidak bisa diubah, bukan reference object element nya. Kalo misal kita membuat Immutable List berisikan data Person, field data Person tetap bisa diubah, tapi isi elemen dari Immutable List tidak bisa diubah lagi
Ini cocok ketika kasus - kasus misal, tidak sembarangan code yang boleh mengubah element di List

## Membuat Immutable List ##
-----------------------------------------------------------------------------------------
Method                              | Keterangan
-----------------------------------------------------------------------------------------
Collections.emptyList()             | Membuat immutable list kosong
Collections.singletonList(e)        | Membuat immutable list berisi 1 element
Collections.unmodifiableList(list)  | Mengubah mutable list menjadi immutable
List.of(e...)                       | Membuat immutable list dari element - element

======================================== Set Interface ========================================
Set adalah salah satu collection yang berisikan elemen-elemen yang unik, atau tidak boleh duplicate
Set tidak memiliki index seperti di List oleh karena itu tidak ada jaminan data yang ada di Set itu akan terurut sesuai dengan waktu kita memasukkan data ke Set
Set tidak memiliki method baru, jadi hanya menggunakan method yang ada di interface parent nya, yaitu Collection dan Iterable
Karena tidak memiliki index, untuk mengambil data di Set juga kita harus melakukan iterasi satu per satu

## Implementasi Set ##

                                  Iterable
                                     ^
                                     |
                                 Collection
                                     ^
                                     |
                        EnumSet --> Set <-- HashSet <----- LinkedHashSet
                                     ^--------------------------/
## HashSet vs LinkedHashSet ##
Di belakang Hashset dan LinkedHashSet sebenarnya sama - sama ada hash table, dimana data disimpan dalam sebuah hash table dengan mengkalkulasi hashCode() function
Yang membedakan adalah, HashSet tidak menjamin data terurut sesuai dengan waktu kita menambahkan data, sedangkan LinkedHashSet menjamin data terurut sesuai dengan waktu kita menambahkan data
Urutan data di LinkedHashSet bisa dijaga karena di belakang nya menggunakan double linked list

======================================== Immutable Set ========================================
Sama seperti LIst, Set pun memiliki tipe data Immutable
Cara pembuatan immutable Set di Java mirip dengan pembuatan immutable List

## Membuat Immutable Set ##
-----------------------------------------------------------------------------------------
Method                              | Keterangan
-----------------------------------------------------------------------------------------
Collections.empty()                 | Membuat immutable set kosong
Collections.singleton(e)            | Membuat immutable set berisi 1 element
Collections.unmodifiableSet(set)   | Mengubah mutable set menjadi immutable
Set.of(e...)                        | Membuat immutable set dari element - element

======================================== SortedSet Interface ========================================
SortedSet adalah turunan dari Set, namun di SortedSet elemen-elemen yang dimasukkan kedalam SortedSet akan otomatis diurutkan
Jika element adalah turunan dari interface Comparable, maka secara otomatis akan diurutkan menggunakan comparable tersebut
Jika element bukan turunan dari interface Comparable, maka kita bisa menggunakan Comparator untuk memberi tahun si SortedSet bagaimana cara mengurutkan elemen-elemen nya

## Implementasi SortedSet ##
                                   Iterable
                                      ^
                                      |
                                  Collection
                                      ^
                                      |
                                     Set
                                      ^
                                      |
                                  SortedSet
                                      ^
                                      |
                                  NavigableSet
                                      ^
                                      |
                                   TreeSet

## Membuat Immutable SortedSet ##
-----------------------------------------------------------------------------------------
Method                                  | Keterangan
-----------------------------------------------------------------------------------------
Collections.emptySortedSet()            | Membuat immutable sorted set kosong
Collections.unmodifiableSortedSet(set)  | Mengubah mutable sorted set menjadi immutable

======================================== NavigableSet Interface ========================================
NavigableSet adalah turunan dari SortedSet
NavigableSet menambah method - method untuk melakukan navigasi pencarian element, seperti mencari elemen yang lebih besar dari, kurang dari mengembalikan urutan set, dan lain - lain

## Membuat Immutable NavigableSet ##
-----------------------------------------------------------------------------------------
Method                                  | Keterangan
-----------------------------------------------------------------------------------------
Collections.emptyNavigableSet()         | Membuat immutable navigable set kosong
Collections.unmodifiableSortedSet(set)  | Mengubah mutable navigable set menjadi immutable

======================================== Queue Interface ========================================
Queue adalah Implementasi dari struktur data Antrian atau FIFO(First In First Out)

## ArrayDeque vs LinkedList vs PriorityQueue ##
ArrayDeque menggunakan array sebagai implementasi queue nya
LinkedList menggunakan double linked list sebagai implementasi queue nya
PriorityQueue menggunakan array sebagai implementasi queue nya, namun diurutkan menggunakan Comparable atau Comparator

## Contoh Method di Queue Interface ##
add(E a)     => Menambahkan data ke antrian, namun jika sudah mencapai kapasitasnya dia akan thrown eror IllegalStateException
offer(E a)   => Menambahkan data ke antrian, namun jika sudah mencapai kapasitasnya tidak akan error namun mengembalikan nilai false saja
remove()     => Ambil dan hapus data terdepan, namun jika antrian sudah kosong di remove maka akan mengembalikan eror NoSuchElementExeption
poll()       => Ambil dan hapus data terdepan, namun jika antrian sudah kosong di remove maka tidak akan eror dan mengembalikan nilai null
element()    => Mengambil data terdepan namun jika data sudah kosong maka akan mengembalikan eror NoSuchElementExeption
peek()       => Mengambil data terdepan namun jika data sudah kosong maka maka tidak akan eror dan mengembalikan nilai null

## Implementasi Queue ##
                                   Iterable
                                     ^
                                     |
                                 Collection
                                     ^
                                     |
                 PriorityQueue --> Queue <-- Dequeue <----- LinkedList
                                                ^   ^-------------/
                                                |
                                           ArrayDeque

## ArrayDeque vs LinkedList vs PriorityQueue ##
ArrayDeque menggunakan array sebagai implementasi queue nya
LinkedList menggunakan double linked list sebagai implementasi queue nya
PriorityQueue menggunakan array sebagai implementasi queue nya, namun diurutkan menggunakan Comparable atau Comparator

======================================== Deque Interface ========================================
Deque singakatan dari double ended queue, artinya queue yang bisa beroprasi dari depan atau belakang
Jika pada queue, operasi yang didukung ada FIFO, namun pada queue, tidak hanya FIFO, namun juga mendukung LIFO(Last In First Out)
Bisa dibilang deque adalah implementasi struktur data antrian dan stack(tumpukan)

## Contoh Method di Queue Interface ##
addFirst(E a)     => Menambahkan data ke antrian terdepan, namun jika sudah mencapai kapasitasnya dia akan thrown eror IllegalStateException
addLast(E a)      => Menambahkan data ke antrian terakhir, namun jika sudah mencapai kapasitasnya dia akan thrown eror IllegalStateException
offerFirst(E a)   => Menambahkan data ke  terdepan, namun jika sudah mencapai kapasitasnya tidak akan error namun mengembalikan nilai false saja
offerLast(E a)   => Menambahkan data ke antrian terakhir, namun jika sudah mencapai kapasitasnya tidak akan error namun mengembalikan nilai false saja
dst ,,.

## Implementasi Deque ##
                                 Iterable
                                     ^
                                     |
                                 Collection
                                     ^
                                     |
                                   Queue
                                     ^
                                     |
                    LinkedList --> Deque <----- ArrayDeque

======================================== Map ========================================
## Map Interface ##
Map adalah struktur data collection yang berisikan mapping antara key dan value
Dimana key di map itu harus unik, tidak boleh duplikat, dan satu key cuma boleh mapping ke satu value
Map sebenernya mirip dengan Array, cuma bedanya kalo di Array, key adalah index(Integer), sedangkan di Map, key nya bebas kita tentukan sesuai keinginan kita

## Contoh Method di Map ##
size() ( mengetahui ukuran map ). isEMpty() ( apakah kosong atau tidak ), containsKey(x) ( apakah terdapat key dengan key x atau tidak ), containsValue(x) ( apakah terdapat value x atau tidak )
get(Object) ( mengambil data dalam map berdasarkan key ), put ( menyimpan data ke dalam map menggunakan key dan value), remove ( menghapus data didalm map berdasarkan key nya)
keySet() ( mengambil semua key dalam suatu map ), values ( mengambil semua value dalm map ) dan masih banyak yang lainnya

## Implementasi Map ##
Implementasi Map adalah HashMap, WeakHashMap, IdentityHashMap, LinkedHashMap, EnumHashMap

## HashMap ##
HashMap adalah implementasi Map yang melakukan distribusi key menggunakan hashCode() function
Karena HashMap sangat bergantung dengan hashCode() function, jadi pastikan kita harus membuat function function hashCode seunik mungkin, karena jika terlalu banyak nilai hashCode() yang sama, maka pendistribusian nya tidak akan optimal sehingga proses get data di Map akan semakin lambat
Di HashMap pengecekan data duplikasi dilakukan dengan menggunakan method equals nya

## WeakHashMap ##
WeakHashMap adalah implementasi Map mirip dengan HashMap
Yang membedakan adalah WeakHashMap menggunakan weak key, dimana jika tidak digunakan lagi maka secara otomatis data di WeakHashMap akan dihapus
Artinya, jika terjadi garbage collection di java, bisa dimungkinkan data di WeakHashMap akan dihapus
WeakHashMap cocok digunakan untuk menyimpan data cache di memory secara sementara

## IdentityHashMap ##
IdentityHashMap adalah implementasi Map sama seperti HashMap
Yang membedakan adalah cara pengecekan kesamaan datanya, tidak menggunakan function equals, melainkan menggunakan operator ==(reference equality)
Artinya data dianggap sama, jika memang lokasi di memory tersebut sama

## LinkedHashMap ##
LinkedHashMap adalah implementasi Map dengan menggunakan double linked list
Data di LinkedHashMap akan lebih terprediksi karena datanya akan disimpan berurutan  dalam linked list sesuai urutan kita menyimpan data
Namun perlu diperhatikan, proses get data di LinkedHashMap akan semakin lambat karena harus melakukan iterasi data linked list terlebih dahulu
Gunakan LinkedHashMap jika memang kita lebih mementingkan iterasi dan Map nya

## EnumMap ##
EnumMap adalah implementasi Map dimana key nya adalah enum
Karena data enum sudah pasti unik, oleh karena itu cocok dijadikan key di Map
Algoritma pendistribusian key dioptimalkan untuk enum, sehingga lebih optimal dibandingkan menggunakan hashCode() method

======================================== Immutable Map ========================================
Sama seperti List dan Set, Map pun punya tipe data Immutable

## Membuat Immutable SortedSet ##
-----------------------------------------------------------------------------------------
Method                                  | Keterangan
-----------------------------------------------------------------------------------------
Collections.emptyMap()                  | Membuat immutable map kosong
Collections.unmodifiableMap(Map)        | Mengubah mutable map menjadi immutable
Collections.singletonMap(key, value)    | Membuat map dengan satu jumlah key-value
Map.of(...)                             | Membuat immutable map dari key-value

======================================== SortedMap Interface ========================================
SortedMap adalah implementasi Map dengan data key diurutkan sesuai dengan Comparable key atau bisa menggunakan Comparator
SortedMap cocok untuk yang posisi key pada Map harus berurut

## Contoh Method di SortedMap ##
subMap( K, K )  : memotong data sortedMap sebagian data
headMap(K)      : get data dari awal sampai key yang ditentukan sesuai parameter
tailMap(K)      : get data dari key yang ditentukan di paramter sampai key yang paling akhir
firsKey()       : Untuk mendapatkan key yang pertama
lastKey()       : Untuk mendapatkan key yang terakhir
dan seterusnya

## Implementasi SortedMap ##
                                    Map
                                     ^
                                     |
                                  SortedMap
                                     ^
                                     |
                                   TreeMap

## Membuat Immutable SortedMap ##
-----------------------------------------------------------------------------------------
Method                                        | Keterangan
-----------------------------------------------------------------------------------------
Collections.emptySortedMap()                  | Membuat immutable sorted map kosong
Collections.unmodifiableSortedMap(Map)        | Mengubah mutable sorted map menjadi immutable

======================================== NavigableMap Interface ========================================
NavigableMap adalah turunan dari SortedMap
Namun NavigableMap memiliki kemampuan navigasi berdasarkan operasi kurang dari, lebih dari dan sejenisnya
Misal, kita ingin mengambil data yang lebih dari key x atau kurang dari key y, ini bisa dilakukan di NavigableMap

## Contoh Method di NavigableMap ##
lowerEntry(K)       : Mengambil entry yang lebih kecil dari key yang ada diparameter
lowerKey(K)         : Mengambil key yang kurang dari parameternya
floorEntry(K)       : Mengambil entry Kurang dari sama dengan parameternya
floorKey(K)         : Mengambil key Kurang dari sama dengan parameternya
ceilingEntry(K)     : Mengambil entry lebih dari sama dengan parameternya
ceilingKey(K)       : Mengambil kay lebih dari sama dengan parameternya
dan seterusnnya

## Implementasi NavigableMap ##
                                    Map
                                     ^
                                     |
                                  SortedMap
                                     ^
                                     |
                                 NavigableMap
                                     ^
                                     |
                                   TreeMap

## Membuat Immutable NavigableMap ##
-----------------------------------------------------------------------------------------
Method                                        | Keterangan
-----------------------------------------------------------------------------------------
Collections.emptyNavigableMap()               | Membuat immutable navigable kosong
Collections.unmodifiableNavigableMap(Map)     | Mengubah mutable navigable map menjadi immutable

======================================== Entry Interface ========================================
Saat kita menyimpan data di Map, data disimpan dalam pair (key-value)
Di java Collection, implementasi Pair di Map bernama Entry
Entry adalah interface sederhana yang berisikan method untuk mengambil key dan value

## Contoh Method di Entry Interface ##
Object ->
            getKey():K      => untuk mendapatkan key
            getValue():V    => untuk mendapatkan value
            setValue(V):V    => untuk merubah value, setKey() tidak ada karena key dalam map tidak bisa diubah
comparingByKey(): Comparator<Entry<K, V>>    =>
comparingByValue(): Comparator<Entry<K, V>>  =>
dan seterusnnya

======================================== Legacy Collection ========================================
Collection sudah ada sejak Java versi 1, namun semakin kesini, Java Collection semakin berkembang
Sebenarnya ada beberapa legacy collection (collection jadul) yang belum kita bahas, namun jarang sekali digunakan sekarang ini

## Vector Class ##
Vector class adalah implementasi dari interface List
Cara kerja Vector mirip dengan ArrayList, yang membedakan adalah semua method di Vector menggunakan kata kunci synchronized yang artinya di thread safe
Namun problemnya adalah karena semua method menggunakan kata kunci synchronized, secara otomatis impact nya ke-performance yang menjadi lambat dibandingkan menggunakan ArrayList
Lantas bagaimana jika kita ingin membuat List yang bisa digunakan di proses paralel?Di versi Java baru, sudah disediakan yang lebih canggih untuk itu,leh karena itu penggunaan Vector sudah jarang sekali ditemui sekarang

## HashTable Class ##
HashTable adalah implementasi dari Map yang mirip dengan HashMap
Sama seperti Vector, semua method di HashTable memiliki kata kunci synchronized, sehingga performanya lebih lambat dibandingkan HashMap
Dan karena di versi Java baru sudah ada juga ConcurentHashMap, sehingga penggunaan HashTable sudah jarang sekali ditemui

## Stack Class ##
Stack adalah implementasi struktur data tumpukan LIFO (Last In First Out)
Namun fitur yang lebih komplit dan konsisten sudah disediakan di Deque, jadi tidak ada alasan lagi menggunakan class Stack























                                               

